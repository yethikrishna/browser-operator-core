var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EntriesFilter_instances, _EntriesFilter_parsedTrace, _EntriesFilter_invisibleEntries, _EntriesFilter_expandableEntries, _EntriesFilter_entryToDescendantsMap, _EntriesFilter_getEntryNode, _EntriesFilter_addExpandableEntry, _EntriesFilter_firstVisibleParentNodeForEntryNode, _EntriesFilter_findAllDescendantsOfNode, _EntriesFilter_findAllRepeatingDescendantsOfNext, _EntriesFilter_makeEntryChildrenVisible;
// Copyright 2023 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import * as Platform from '../../core/platform/platform.js';
import * as Trace from '../../models/trace/trace.js';
import * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';
import { entryIsVisibleInTimeline, } from './CompatibilityTracksAppender.js';
/**
 * This class can take in a thread that has been generated by the
 * RendererHandler and apply certain actions to it in order to modify what is
 * shown to the user. These actions can be automatically applied by DevTools or
 * applied by the user.
 *
 * Once actions are applied, the invisibleEntries() method will return the
 * entries that are invisible, and this is the list of entries that should be
 * removed before rendering the resulting thread on the timeline.
 */
export class EntriesFilter {
    constructor(parsedTrace) {
        _EntriesFilter_instances.add(this);
        _EntriesFilter_parsedTrace.set(this, void 0);
        // Track the set of invisible entries.
        _EntriesFilter_invisibleEntries.set(this, []);
        // List of entries whose children are hidden. This list is used to
        // keep track of entries that should be identified in the UI as "expandable",
        // since they can be clicked to reveal their hidden children.
        _EntriesFilter_expandableEntries.set(this, []);
        // Cache for descendants of entry that have already been gathered. The descendants
        // will never change so we can avoid running the potentially expensive search again.
        _EntriesFilter_entryToDescendantsMap.set(this, new Map());
        __classPrivateFieldSet(this, _EntriesFilter_parsedTrace, parsedTrace, "f");
    }
    /**
     * Checks which actions can be applied on an entry. This allows us to only show possible actions in the Context Menu.
     * For example, if an entry has no children, COLLAPSE_FUNCTION will not change the FlameChart, therefore there is no need to show this action as an option.
     */
    findPossibleActions(entry) {
        const entryNode = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_getEntryNode).call(this, entry);
        if (!entryNode) {
            // Invalid node was given, return no possible actions.
            return {
                ["MERGE_FUNCTION" /* PerfUI.FlameChart.FilterAction.MERGE_FUNCTION */]: false,
                ["COLLAPSE_FUNCTION" /* PerfUI.FlameChart.FilterAction.COLLAPSE_FUNCTION */]: false,
                ["COLLAPSE_REPEATING_DESCENDANTS" /* PerfUI.FlameChart.FilterAction.COLLAPSE_REPEATING_DESCENDANTS */]: false,
                ["RESET_CHILDREN" /* PerfUI.FlameChart.FilterAction.RESET_CHILDREN */]: false,
                ["UNDO_ALL_ACTIONS" /* PerfUI.FlameChart.FilterAction.UNDO_ALL_ACTIONS */]: false,
            };
        }
        const entryParent = entryNode.parent;
        const allVisibleDescendants = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_findAllDescendantsOfNode).call(this, entryNode).filter(descendant => !__classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f").includes(descendant));
        const allVisibleRepeatingDescendants = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_findAllRepeatingDescendantsOfNext).call(this, entryNode).filter(descendant => !__classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f").includes(descendant));
        const allInVisibleDescendants = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_findAllDescendantsOfNode).call(this, entryNode).filter(descendant => __classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f").includes(descendant));
        // If there are children to hide, indicate action as possible
        const possibleActions = {
            ["MERGE_FUNCTION" /* PerfUI.FlameChart.FilterAction.MERGE_FUNCTION */]: entryParent !== null,
            ["COLLAPSE_FUNCTION" /* PerfUI.FlameChart.FilterAction.COLLAPSE_FUNCTION */]: allVisibleDescendants.length > 0,
            ["COLLAPSE_REPEATING_DESCENDANTS" /* PerfUI.FlameChart.FilterAction.COLLAPSE_REPEATING_DESCENDANTS */]: allVisibleRepeatingDescendants.length > 0,
            ["RESET_CHILDREN" /* PerfUI.FlameChart.FilterAction.RESET_CHILDREN */]: allInVisibleDescendants.length > 0,
            ["UNDO_ALL_ACTIONS" /* PerfUI.FlameChart.FilterAction.UNDO_ALL_ACTIONS */]: __classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f").length > 0,
        };
        return possibleActions;
    }
    /**
     * Returns the amount of entry descendants that belong to the hidden entries array.
     * */
    findHiddenDescendantsAmount(entry) {
        const entryNode = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_getEntryNode).call(this, entry);
        if (!entryNode) {
            return 0;
        }
        const allDescendants = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_findAllDescendantsOfNode).call(this, entryNode);
        return allDescendants.filter(descendant => this.invisibleEntries().includes(descendant)).length;
    }
    /**
     * Returns the set of entries that are invisible given the set of applied actions.
     */
    invisibleEntries() {
        return __classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f");
    }
    /**
     * Sets hidden and expandable. Called when a trace with modifications is loaded and some entries are set as hidden and expandable.
     * Both arrays are set together because if there is one, the other must be present too.
     */
    setHiddenAndExpandableEntries(invisibleEntries, expandableEntries) {
        __classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f").push(...invisibleEntries);
        __classPrivateFieldGet(this, _EntriesFilter_expandableEntries, "f").push(...expandableEntries);
    }
    entryIsInvisible(entry) {
        return __classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f").includes(entry);
    }
    /**
     * Returns the array of entries that have a sign indicating that entries below are hidden,
     * and so that they can be "expanded" to reveal their hidden children.
     */
    expandableEntries() {
        return __classPrivateFieldGet(this, _EntriesFilter_expandableEntries, "f");
    }
    /**
     * Applies an action to hide entries or removes entries
     * from hidden entries array depending on the action.
     */
    applyFilterAction(action) {
        // We apply new user action to the set of all entries, and mark
        // any that should be hidden by adding them to this set.
        // Another approach would be to use splice() to remove items from the
        // array, but doing this would be a mutation of the arry for every hidden
        // event. Instead, we add entries to this set and return it as an array at the end.
        const entriesToHide = new Set();
        switch (action.type) {
            case "MERGE_FUNCTION" /* PerfUI.FlameChart.FilterAction.MERGE_FUNCTION */: {
                // The entry that was clicked on is merged into its parent. All its
                // children remain visible, so we just have to hide the entry that was
                // selected.
                entriesToHide.add(action.entry);
                // If parent node exists, add it to expandableEntries, so it would be possible to uncollapse its children.
                const actionNode = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_getEntryNode).call(this, action.entry) || null;
                const parentNode = actionNode && __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_firstVisibleParentNodeForEntryNode).call(this, actionNode);
                if (parentNode) {
                    __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_addExpandableEntry).call(this, parentNode.entry);
                }
                break;
            }
            case "COLLAPSE_FUNCTION" /* PerfUI.FlameChart.FilterAction.COLLAPSE_FUNCTION */: {
                // The entry itself remains visible, but all of its descendants are hidden.
                const entryNode = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_getEntryNode).call(this, action.entry);
                if (!entryNode) {
                    // Invalid node was given, just ignore and move on.
                    break;
                }
                const allDescendants = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_findAllDescendantsOfNode).call(this, entryNode);
                allDescendants.forEach(descendant => entriesToHide.add(descendant));
                __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_addExpandableEntry).call(this, action.entry);
                break;
            }
            case "COLLAPSE_REPEATING_DESCENDANTS" /* PerfUI.FlameChart.FilterAction.COLLAPSE_REPEATING_DESCENDANTS */: {
                const entryNode = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_getEntryNode).call(this, action.entry);
                if (!entryNode) {
                    // Invalid node was given, just ignore and move on.
                    break;
                }
                const allRepeatingDescendants = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_findAllRepeatingDescendantsOfNext).call(this, entryNode);
                allRepeatingDescendants.forEach(descendant => entriesToHide.add(descendant));
                if (entriesToHide.size > 0) {
                    __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_addExpandableEntry).call(this, action.entry);
                }
                break;
            }
            case "UNDO_ALL_ACTIONS" /* PerfUI.FlameChart.FilterAction.UNDO_ALL_ACTIONS */: {
                __classPrivateFieldSet(this, _EntriesFilter_invisibleEntries, [], "f");
                __classPrivateFieldSet(this, _EntriesFilter_expandableEntries, [], "f");
                break;
            }
            case "RESET_CHILDREN" /* PerfUI.FlameChart.FilterAction.RESET_CHILDREN */: {
                __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_makeEntryChildrenVisible).call(this, action.entry);
                break;
            }
            default:
                Platform.assertNever(action.type, `Unknown EntriesFilter action: ${action.type}`);
        }
        __classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f").push(...entriesToHide);
        return __classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f");
    }
    firstVisibleParentEntryForEntry(entry) {
        const node = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_getEntryNode).call(this, entry);
        if (!node) {
            return null;
        }
        const parent = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_firstVisibleParentNodeForEntryNode).call(this, node);
        return parent ? parent.entry : null;
    }
    /**
     * If an entry was selected from a link instead of clicking on it,
     * it might be in the invisible entries array.
     * If it is, reveal it by resetting clidren the closest expandable entry,
     */
    revealEntry(entry) {
        const entryNode = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_getEntryNode).call(this, entry);
        if (!entryNode) {
            // Invalid node was given, just ignore and move on.
            return;
        }
        let closestExpandableParent = entryNode;
        while (closestExpandableParent.parent && !__classPrivateFieldGet(this, _EntriesFilter_expandableEntries, "f").includes(closestExpandableParent.entry)) {
            closestExpandableParent = closestExpandableParent.parent;
        }
        __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_makeEntryChildrenVisible).call(this, closestExpandableParent.entry);
    }
    isEntryExpandable(event) {
        return __classPrivateFieldGet(this, _EntriesFilter_expandableEntries, "f").includes(event);
    }
}
_EntriesFilter_parsedTrace = new WeakMap(), _EntriesFilter_invisibleEntries = new WeakMap(), _EntriesFilter_expandableEntries = new WeakMap(), _EntriesFilter_entryToDescendantsMap = new WeakMap(), _EntriesFilter_instances = new WeakSet(), _EntriesFilter_getEntryNode = function _EntriesFilter_getEntryNode(entry) {
    // The entry might be either from the Samples handler or Renderer handler. So we need to check both handlers to find
    // the EntryNode.
    return __classPrivateFieldGet(this, _EntriesFilter_parsedTrace, "f").Samples.entryToNode.get(entry) ?? __classPrivateFieldGet(this, _EntriesFilter_parsedTrace, "f").Renderer.entryToNode.get(entry);
}, _EntriesFilter_addExpandableEntry = function _EntriesFilter_addExpandableEntry(entry) {
    __classPrivateFieldGet(this, _EntriesFilter_expandableEntries, "f").push(entry);
    const entryNode = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_getEntryNode).call(this, entry);
    if (!entryNode) {
        // Invalid node was given, just ignore and move on.
        return;
    }
    const allDescendants = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_findAllDescendantsOfNode).call(this, entryNode);
    if (allDescendants.length > 0) {
        __classPrivateFieldSet(this, _EntriesFilter_expandableEntries, __classPrivateFieldGet(this, _EntriesFilter_expandableEntries, "f").filter(entry => {
            return !allDescendants.includes(entry);
        }), "f");
    }
}, _EntriesFilter_firstVisibleParentNodeForEntryNode = function _EntriesFilter_firstVisibleParentNodeForEntryNode(node) {
    let parent = node.parent;
    while ((parent && __classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f").includes(parent.entry)) ||
        (parent && !entryIsVisibleInTimeline(parent.entry))) {
        parent = parent.parent;
    }
    return parent;
}, _EntriesFilter_findAllDescendantsOfNode = function _EntriesFilter_findAllDescendantsOfNode(root) {
    const cachedDescendants = __classPrivateFieldGet(this, _EntriesFilter_entryToDescendantsMap, "f").get(root);
    if (cachedDescendants) {
        return cachedDescendants;
    }
    const descendants = [];
    // Walk through all the descendants, starting at the root node.
    const children = [...root.children];
    while (children.length > 0) {
        const childNode = children.shift();
        if (childNode) {
            descendants.push(childNode.entry);
            const childNodeCachedDescendants = __classPrivateFieldGet(this, _EntriesFilter_entryToDescendantsMap, "f").get(childNode);
            // If the descendants of a child are cached, get them from the cache instead of iterating through them again
            if (childNodeCachedDescendants) {
                descendants.push(...childNodeCachedDescendants);
            }
            else {
                children.push(...childNode.children);
            }
        }
    }
    __classPrivateFieldGet(this, _EntriesFilter_entryToDescendantsMap, "f").set(root, descendants);
    return descendants;
}, _EntriesFilter_findAllRepeatingDescendantsOfNext = function _EntriesFilter_findAllRepeatingDescendantsOfNext(root) {
    // Walk through all the ancestors, starting at the root node.
    const children = [...root.children];
    const repeatingNodes = [];
    const rootIsProfileCall = Trace.Types.Events.isProfileCall(root.entry);
    while (children.length > 0) {
        const childNode = children.shift();
        if (childNode) {
            const childIsProfileCall = Trace.Types.Events.isProfileCall(childNode.entry);
            if ( /* Handle SyntheticProfileCalls */rootIsProfileCall && childIsProfileCall) {
                const rootNodeEntry = root.entry;
                const childNodeEntry = childNode.entry;
                if (Trace.Helpers.SamplesIntegrator.SamplesIntegrator.framesAreEqual(rootNodeEntry.callFrame, childNodeEntry.callFrame)) {
                    repeatingNodes.push(childNode.entry);
                }
            } /* Handle Renderer events */
            else if (!rootIsProfileCall && !childIsProfileCall) {
                if (root.entry.name === childNode.entry.name) {
                    repeatingNodes.push(childNode.entry);
                }
            }
            children.push(...childNode.children);
        }
    }
    return repeatingNodes;
}, _EntriesFilter_makeEntryChildrenVisible = function _EntriesFilter_makeEntryChildrenVisible(entry) {
    const entryNode = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_getEntryNode).call(this, entry);
    if (!entryNode) {
        // Invalid node was given, just ignore and move on.
        return;
    }
    const descendants = __classPrivateFieldGet(this, _EntriesFilter_instances, "m", _EntriesFilter_findAllDescendantsOfNode).call(this, entryNode);
    /**
     * Filter out all descendant of the node
     * from the invisible entries list.
     */
    __classPrivateFieldSet(this, _EntriesFilter_invisibleEntries, __classPrivateFieldGet(this, _EntriesFilter_invisibleEntries, "f").filter(entry => {
        if (descendants.includes(entry)) {
            return false;
        }
        return true;
    }), "f");
    /**
     * Filter out all descentants and entry from expandable entries
     * list to not show that some entries below those are hidden.
     */
    __classPrivateFieldSet(this, _EntriesFilter_expandableEntries, __classPrivateFieldGet(this, _EntriesFilter_expandableEntries, "f").filter(iterEntry => {
        if (descendants.includes(iterEntry) || iterEntry === entry) {
            return false;
        }
        return true;
    }), "f");
};
//# sourceMappingURL=EntriesFilter.js.map